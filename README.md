# LeNet5-Implementation-
This LeNet5 model is implemented using PyTorch

LeNet-5는 
인풋(Input) 레이어, 
3개의 컨볼루션 레이어(C1, C3, C5), 
2개의 서브샘플링 레이어(Subsampling layer or Pooling layer)(S2, S4), 
1층의 full-connected 레이어(F6), 아웃풋(Output) 레이어로 구성되어 있다. 
참고로 C1부터 F6까지 활성화 함수로 tanh(hypobolic tangent)을 사용한다.

C1 layer<Convolution>
  
C1 에서 입력 이미지(32x32 사이즈)을 6개(6채널)의 5x5 필터와 컨볼류션 연산을 해준다. 그결과 6장의 28x28 특성 맵(feature map)을 얻게 된다.

  
S2 layer<Subsampling>
  
6장의 28x28 특성 맵에 대햇 서브샘플링(subsampling, pooling)을 진행한다. 결과적으로 28x28 사이즈의 특성 맵이 6장의 14x14 사이즈의 특성맵으로 축소된다. 
2x2 필터를 stride 2로 설정해서 섬브샘플링 해주기 때문이다. 여기서 사용하는 서브샘플링 방법은 평균 풀링이다.

  
C3 layer
<img width="793" alt="Screen Shot 2022-05-31 at 1 44 26 PM" src="https://user-images.githubusercontent.com/93589860/171094514-56d1edd0-074b-40fc-bdc5-da4241d7da97.png">

6장의 14x14 특성맵에 5x5 커널의 컨볼루션 연산을 수행해서 16장의 10x10 특성맵을 산출해낸다. 
**왜 16장이 나오는지에 대한 설명(그림 참고)(그리고 연속된 3장, 4장, 불연속 4장 이런 hyper parameter값은 논문 작성자가 임의로 선택한 값)
  1. 6장의 14x14 특성맵에서 연속된 3장씩을 모아서 5x5x3 사이즈의 필터와 컨볼루션 해준다(그림에서 열 0-5). 6장의 10x10 특성맵이 산출됨.
  2. 6장의 14x14 특성맵에서 연속된 4장씩을 모아서 5x5x4 사이즈의 필터와 컨볼루션 해준다(그림에서 열 6-11). 6장의 10x10 특성맵이 산출됨.
  3. 6장의 14x14 특성맵에서 불연속된 4장씩을 모아서 5x5x4 사이즈의 필터와 컨볼루션 해준다(그림에서 열 12-14). 3장의 10x10 특성맵이 산출됨.
  4. 마지막으로 6장의 14x14 특성맵에서 모두를 가지고서 5x5x6 사이즈의 필터와 컨볼루션 해준다(그림에서 열 15). 1장의 10x10 특성맵이 산출됨.
  5. 결과적으로 6+6+3+1 = 16장의 특성맵 얻게 됨
  
  
S4 layer
  
16장의 10x10 특성 맵에 대해서 서브 샘플링을 진행해 16장의 5x5 특성 맵으로 축소시킨다. (2x2 필터, stride 2)
  
  
C5 layer
  
16장의 5x5 특성맵을 120개의 5x5x16 사이즈의 필터와 컨볼루션 해준다. 결과적으로 120개의 1x1 특성맵이 산출된다.
  

F6 layer<Fully-Connected>
84개의 유닛을 가진 피드포워드 신경망이다. C5의 결과를 84개의 유닛에 연결시킨다.
LeNet에서는 아직 역전파를 사용하지 않는다
  

Output layer
10개의 Euclidena radial basis function(RBF) 유닛들로 구성되어있다. 각각 F6의 84개 유닛으로부터 인풋을 받는다. 최종적으로 이미지가 속한 클래스를 알려준다. 
10개의 출력에서 각각이 특정 이미지일 확률을 나타낸다.
RBF에서는 학습할 때 역전파를 사용한다.
